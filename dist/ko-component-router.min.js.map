{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ko-component-router.min.js","webpack:///webpack/bootstrap 962d751755a8caea3622","webpack:///./src/index.js","webpack:///external {\"root\":\"ko\",\"commonjs\":\"knockout\",\"commonjs2\":\"knockout\",\"amd\":\"knockout\"}","webpack:///./src/router.js","webpack:///./src/context.js","webpack:///./~/qs/lib/index.js","webpack:///./~/qs/lib/stringify.js","webpack:///./~/qs/lib/utils.js","webpack:///./~/qs/lib/parse.js","webpack:///./src/query.js","webpack:///./src/utils.js","webpack:///./src/state.js","webpack:///./src/route.js","webpack:///./~/path-to-regexp/index.js","webpack:///./~/isarray/index.js","webpack:///./src/binding.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_knockout","_knockout2","_router","_router2","components","register","synchronous","viewModel","template","_classCallCheck","instance","Constructor","TypeError","createViewModel","routerParams","componentInfo","el","element","bindingCtx","contextFor","Router","toJS","which","e","window","event","button","noop","sameOrigin","href","origin","location","protocol","hostname","port","indexOf","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_context","_context2","_route","_route2","_utils","clickEvent","isUndefined","document","ontouchstart","_ref","routes","_ref$base","base","undefined","_ref$hashbang","hashbang","_ref$inTransition","inTransition","_ref$outTransition","outTransition","_ref$persistState","persistState","_ref$persistQuery","persistQuery","route","config","ctx","onpopstate","bind","onclick","addEventListener","dispatch","$parent","path","canonicalPath","hash","substr","search","pathname","_ref2","state","_ref2$pushState","pushState","toLowerCase","update","_ref3","depth","metaKey","ctrlKey","shiftKey","nodeName","parentNode","isDownload","hasAttribute","hasOtherTarget","hasExternalRel","getAttribute","isMailto","isCrossOrigin","isEmptyHash","orig","replace","preventDefault","removeEventListener","destroy","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","Array","isArray","_qs","_qs2","_query","_state","Context","$router","parentRouterBindingCtx","isRoot","$parentContext","router","$child","getDepth","isNavigating","observable","params","query","complete","animate","_this","getElementsByClassName","toCtx","extend","tasks","runEarly","schedule","fromCtx","origUrl","arguments","url","getRouteForUrl","firstRun","_$parent","apply","getAll","_route$parse","parse","_route$parse2","querystring","childPath","samePage","reload","getCanonicalPath","getBase","getFullQueryString","history","title","split","matchingRouteWithFewestDynamicSegments","fewestMatchingSegments","Infinity","rn","r","matches","_keys","pattern","dispose","Stringify","Parse","stringify","Utils","arrayPrefixGenerators","brackets","prefix","indices","repeat","defaults","delimiter","strictNullHandling","skipNulls","encode","encoder","object","generateArrayPrefix","filter","sort","allowDots","Date","toISOString","isBuffer","String","values","objKeys","keys","concat","opts","options","arrayFormat","join","hexTable","array","toString","toUpperCase","arrayToObject","source","plainObjects","create","merge","mergeTarget","reduce","acc","hasOwnProperty","decode","str","decodeURIComponent","string","out","charCodeAt","charAt","compact","references","refs","lookup","compacted","j","isRegExp","constructor","arrayLimit","parameterLimit","allowPrototypes","decoder","parseValues","parts","part","pos","slice","val","parseObject","chain","shift","cleanRoot","index","parseInt","isNaN","parseArrays","parseKeys","givenKey","parent","child","segment","exec","tempObj","newObj","_defineProperty","Query","qsParams","trigger","cache","qsIndex","updateFromString","get","clear","prop","defaultVal","parser","identity","guid","pureComputed","read","write","v","deepEquals","prev","getNonDefaultParams","owner","asObservable","q","pn","mapKeys","force","nonDefaultParams","workingParams","d","decodeURLEncodedURIComponent","foo","bar","_typeof","isPrimitiveOrDate","fooProps","barProps","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","dest","src","createAsObservable","_shallow","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","fromJS","isWritableObservable","x","fn","mappedObj","forEach","k","parentIsArray","obs","observableArray","Number","Boolean","s","replaceState","_dispose","newState","_pathToRegexp","_pathToRegexp2","Route","component","_regexp","hIndex","len","name","substring","lastIndexOf","res","tokens","PATH_REGEXP","escaped","offset","capture","group","modifier","asterisk","partial","optional","escapeGroup","compile","tokensToFunction","encodeURIComponentPretty","encodeURI","encodeAsterisk","RegExp","data","pretty","encodeURIComponent","token","isarray","JSON","test","escapeString","attachKeys","re","flags","sensitive","regexpToRegexp","groups","match","arrayToRegexp","pathToRegexp","regexp","stringToRegexp","tokensToRegExp","strict","end","lastToken","endsWithSlash","resolveHref","_getRoute","getRoute","_getRoute2","applyBinding","bindings","has","bindingsToApply","click","debounce","modifierKey","_getRoute3","_getRoute4","handled","stopImmediatePropagation","console","error","attr","css","active-path","_getRoute5","_getRoute6","applyBindingsToNode","getRouter","unwrap","bindingHandlers","init","xx","b","utils"],"mappings":"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","file":"ko-component-router.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"knockout\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"knockout\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ko-component-router\"] = factory(require(\"knockout\"));\n\telse\n\t\troot[\"ko-component-router\"] = factory(root[\"ko\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"knockout\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"knockout\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ko-component-router\"] = factory(require(\"knockout\"));\n\telse\n\t\troot[\"ko-component-router\"] = factory(root[\"ko\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _knockout = __webpack_require__(1);\n\t\n\tvar _knockout2 = _interopRequireDefault(_knockout);\n\t\n\tvar _router = __webpack_require__(2);\n\t\n\tvar _router2 = _interopRequireDefault(_router);\n\t\n\t__webpack_require__(14);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_knockout2.default.components.register('ko-component-router', {\n\t  synchronous: true,\n\t  viewModel: _router2.default,\n\t  template: '<div data-bind=\\'if: ctx.route().component\\'>\\n      <div class=\"component-wrapper\" data-bind=\\'component: {\\n        name: ctx.route().component,\\n        params: ctx\\n      }\\'></div>\\n    </div>'\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _knockout = __webpack_require__(1);\n\t\n\tvar _knockout2 = _interopRequireDefault(_knockout);\n\t\n\tvar _context = __webpack_require__(3);\n\t\n\tvar _context2 = _interopRequireDefault(_context);\n\t\n\tvar _route = __webpack_require__(11);\n\t\n\tvar _route2 = _interopRequireDefault(_route);\n\t\n\tvar _utils = __webpack_require__(9);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar clickEvent = !(0, _utils.isUndefined)(document) && document.ontouchstart ? 'touchstart' : 'click';\n\t\n\tvar Router = function () {\n\t  function Router(el, bindingCtx, _ref) {\n\t    var routes = _ref.routes;\n\t    var _ref$base = _ref.base;\n\t    var base = _ref$base === undefined ? '' : _ref$base;\n\t    var _ref$hashbang = _ref.hashbang;\n\t    var hashbang = _ref$hashbang === undefined ? false : _ref$hashbang;\n\t    var _ref$inTransition = _ref.inTransition;\n\t    var inTransition = _ref$inTransition === undefined ? noop : _ref$inTransition;\n\t    var _ref$outTransition = _ref.outTransition;\n\t    var outTransition = _ref$outTransition === undefined ? noop : _ref$outTransition;\n\t    var _ref$persistState = _ref.persistState;\n\t    var persistState = _ref$persistState === undefined ? false : _ref$persistState;\n\t    var _ref$persistQuery = _ref.persistQuery;\n\t    var persistQuery = _ref$persistQuery === undefined ? false : _ref$persistQuery;\n\t\n\t    _classCallCheck(this, Router);\n\t\n\t    for (var route in routes) {\n\t      routes[route] = new _route2.default(route, routes[route]);\n\t    }\n\t\n\t    this.config = {\n\t      el: el,\n\t      base: base,\n\t      hashbang: hashbang,\n\t      routes: routes,\n\t      inTransition: inTransition,\n\t      outTransition: outTransition,\n\t      persistState: persistState,\n\t      persistQuery: persistQuery\n\t    };\n\t\n\t    this.ctx = new _context2.default(bindingCtx, this.config);\n\t\n\t    this.onpopstate = this.onpopstate.bind(this);\n\t    this.onclick = this.onclick.bind(this);\n\t    window.addEventListener('popstate', this.onpopstate, false);\n\t    document.addEventListener(clickEvent, this.onclick, false);\n\t\n\t    var dispatch = true;\n\t    if (this.ctx.$parent) {\n\t      dispatch = this.ctx.$parent.path() !== this.ctx.$parent.canonicalPath();\n\t    }\n\t\n\t    if (dispatch) {\n\t      var path = this.config.hashbang && ~location.hash.indexOf('#!') ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n\t\n\t      this.dispatch({ path: path });\n\t    }\n\t  }\n\t\n\t  _createClass(Router, [{\n\t    key: 'dispatch',\n\t    value: function dispatch(_ref2) {\n\t      var path = _ref2.path;\n\t      var state = _ref2.state;\n\t      var _ref2$pushState = _ref2.pushState;\n\t      var pushState = _ref2$pushState === undefined ? false : _ref2$pushState;\n\t\n\t      if (path.toLowerCase().indexOf(this.config.base.toLowerCase()) === 0) {\n\t        path = path.substr(this.config.base.length) || '/';\n\t      }\n\t\n\t      return this.ctx.update(path, state, pushState, false);\n\t    }\n\t  }, {\n\t    key: 'onpopstate',\n\t    value: function onpopstate(_ref3) {\n\t      var state = _ref3.state;\n\t\n\t      this.dispatch({\n\t        path: location.pathname + location.search + location.hash,\n\t        state: (state || {})[this.ctx.config.depth + this.ctx.pathname()]\n\t      });\n\t    }\n\t  }, {\n\t    key: 'onclick',\n\t    value: function onclick(e) {\n\t      if (1 !== which(e) || e.metaKey || e.ctrlKey || e.shiftKey) {\n\t        return;\n\t      }\n\t\n\t      // ensure link\n\t      var el = e.target;\n\t      while (el && 'A' !== el.nodeName) {\n\t        el = el.parentNode;\n\t      }\n\t      if (!el || 'A' !== el.nodeName) {\n\t        return;\n\t      }\n\t\n\t      var isDownload = el.hasAttribute('download');\n\t      var hasOtherTarget = el.hasAttribute('target');\n\t      var hasExternalRel = el.getAttribute('rel') === 'external';\n\t      var isMailto = ~(el.getAttribute('href') || '').indexOf('mailto:');\n\t      var isCrossOrigin = !sameOrigin(el.href);\n\t      var isEmptyHash = el.getAttribute('href') === '#';\n\t\n\t      if (isDownload || hasOtherTarget || hasExternalRel || isMailto || isCrossOrigin || isEmptyHash) {\n\t        return;\n\t      }\n\t\n\t      // rebuild path\n\t      var path = el.pathname + el.search + (el.hash || '');\n\t\n\t      // same page\n\t      var orig = path;\n\t      var base = this.config.base.replace('/#!', '');\n\t      if (path.toLowerCase().indexOf(base.toLowerCase()) === 0) {\n\t        path = path.substr(base.length);\n\t      }\n\t\n\t      if (this.config.hashbang) {\n\t        path = path.replace('/#!', '');\n\t      }\n\t\n\t      if (this.config.base && orig === path) {\n\t        return;\n\t      }\n\t\n\t      if (this.dispatch({ path: path, pushState: true })) {\n\t        e.preventDefault();\n\t      }\n\t    }\n\t  }, {\n\t    key: 'dispose',\n\t    value: function dispose() {\n\t      document.removeEventListener(clickEvent, this.onclick, false);\n\t      window.removeEventListener('popstate', this.onpopstate, false);\n\t      this.ctx.destroy();\n\t    }\n\t  }]);\n\t\n\t  return Router;\n\t}();\n\t\n\tfunction createViewModel(routerParams, componentInfo) {\n\t  var el = componentInfo.element;\n\t  var bindingCtx = _knockout2.default.contextFor(el);\n\t  return new Router(el, bindingCtx, _knockout2.default.toJS(routerParams));\n\t}\n\t\n\tfunction which(e) {\n\t  e = e || window.event;\n\t  return null === e.which ? e.button : e.which;\n\t}\n\t\n\tfunction noop() {}\n\t\n\tfunction sameOrigin(href) {\n\t  var origin = location.protocol + '//' + location.hostname;\n\t  if (location.port) origin += ':' + location.port;\n\t  return href && 0 === href.indexOf(origin);\n\t}\n\t\n\texports.default = { createViewModel: createViewModel };\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _knockout = __webpack_require__(1);\n\t\n\tvar _knockout2 = _interopRequireDefault(_knockout);\n\t\n\tvar _qs = __webpack_require__(4);\n\t\n\tvar _qs2 = _interopRequireDefault(_qs);\n\t\n\tvar _query = __webpack_require__(8);\n\t\n\tvar _state = __webpack_require__(10);\n\t\n\tvar _utils = __webpack_require__(9);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Context = function () {\n\t  function Context(bindingCtx, config) {\n\t    _classCallCheck(this, Context);\n\t\n\t    bindingCtx.$router = this;\n\t\n\t    var parentRouterBindingCtx = bindingCtx;\n\t    var isRoot = true;\n\t    while (parentRouterBindingCtx.$parentContext) {\n\t      parentRouterBindingCtx = parentRouterBindingCtx.$parentContext;\n\t      if (parentRouterBindingCtx.$router) {\n\t        isRoot = false;\n\t        break;\n\t      } else {\n\t        parentRouterBindingCtx.$router = this;\n\t      }\n\t    }\n\t\n\t    if (isRoot) {\n\t      _knockout2.default.router = this;\n\t    } else {\n\t      this.$parent = parentRouterBindingCtx.$router;\n\t      this.$parent.$child = this;\n\t      config.base = this.$parent.pathname();\n\t    }\n\t\n\t    this.config = config;\n\t    this.config.depth = Context.getDepth(this);\n\t\n\t    this.isNavigating = _knockout2.default.observable(true);\n\t\n\t    this.route = _knockout2.default.observable('');\n\t    this.canonicalPath = _knockout2.default.observable('');\n\t    this.path = _knockout2.default.observable('');\n\t    this.pathname = _knockout2.default.observable('');\n\t    this.hash = _knockout2.default.observable('');\n\t    this.params = {};\n\t    this.query = (0, _query.factory)(this);\n\t    this.state = (0, _state.factory)(this);\n\t  }\n\t\n\t  _createClass(Context, [{\n\t    key: 'update',\n\t    value: function update() {\n\t      var origUrl = arguments.length <= 0 || arguments[0] === undefined ? this.canonicalPath() : arguments[0];\n\t      var state = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t      var push = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];\n\t      var query = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\t\n\t      var url = (origUrl + '').replace('/#!', '');\n\t\n\t      if (url.indexOf('./') === 0) {\n\t        url = url.replace('./', '/');\n\t      } else {\n\t        var p = this;\n\t        while (p && url.indexOf(p.config.base) > -1) {\n\t          url = url.replace(p.config.base, '');\n\t          p = p.$parent;\n\t        }\n\t      }\n\t\n\t      var route = this.getRouteForUrl(url);\n\t      var firstRun = this.route() === '';\n\t\n\t      if (!route) {\n\t        var _$parent;\n\t\n\t        return this.$parent ? (_$parent = this.$parent).update.apply(_$parent, arguments) : false;\n\t      }\n\t\n\t      var fromCtx = _knockout2.default.toJS({\n\t        route: this.route,\n\t        path: this.path,\n\t        pathname: this.pathname,\n\t        canonicalPath: this.canonicalPath,\n\t        hash: this.hash,\n\t        state: this.state,\n\t        params: this.params,\n\t        query: this.query.getAll(false, this.pathname())\n\t      });\n\t\n\t      var _route$parse = route.parse(url);\n\t\n\t      var _route$parse2 = _slicedToArray(_route$parse, 6);\n\t\n\t      var path = _route$parse2[0];\n\t      var params = _route$parse2[1];\n\t      var hash = _route$parse2[2];\n\t      var pathname = _route$parse2[3];\n\t      var querystring = _route$parse2[4];\n\t      var childPath = _route$parse2[5];\n\t\n\t\n\t      var samePage = this.pathname() === pathname;\n\t      if (!samePage && !firstRun) {\n\t        this.isNavigating(true);\n\t        this.reload();\n\t      }\n\t\n\t      if (!query && querystring) {\n\t        query = _qs2.default.parse(querystring)[this.config.depth + pathname];\n\t      }\n\t\n\t      var canonicalPath = Context.getCanonicalPath(Context.getBase(this).replace(/\\/$/, ''), pathname, childPath, this.query.getFullQueryString(query, pathname), hash);\n\t\n\t      var toCtx = {\n\t        route: route,\n\t        path: path,\n\t        pathname: pathname,\n\t        canonicalPath: canonicalPath,\n\t        hash: hash,\n\t        params: params,\n\t        query: query\n\t      };\n\t\n\t      if (state === false && samePage) {\n\t        (0, _utils.extend)(toCtx, { state: fromCtx.state }, false);\n\t      } else if (!this.config.persistState && state) {\n\t        toCtx.state = state;\n\t      }\n\t\n\t      if (this.config.persistState) {\n\t        toCtx.state = this.state();\n\t      }\n\t\n\t      history[push ? 'pushState' : 'replaceState'](history.state, document.title, '' === canonicalPath ? Context.getBase(this) : canonicalPath);\n\t\n\t      if (firstRun) {\n\t        complete.call(this, true);\n\t      } else if (!samePage) {\n\t        this.config.outTransition(this.config.el, fromCtx, toCtx, complete.bind(this));\n\t\n\t        if (this.config.outTransition.length !== 4) {\n\t          complete.call(this, true);\n\t        }\n\t      } else if (this.$child) {\n\t        this.$child.update(childPath || '/', {}, false, {});\n\t        complete.call(this);\n\t      } else {\n\t        complete.call(this);\n\t      }\n\t\n\t      function complete(animate) {\n\t        var _this = this;\n\t\n\t        var el = this.config.el.getElementsByClassName('component-wrapper')[0];\n\t        delete toCtx.query;\n\t        (0, _utils.extend)(this, toCtx);\n\t        if (query) {\n\t          this.query.update(query, pathname);\n\t        }\n\t        this.isNavigating(false);\n\t        _knockout2.default.tasks.runEarly();\n\t\n\t        if (animate) {\n\t          _knockout2.default.tasks.schedule(function () {\n\t            return _this.config.inTransition(el, fromCtx, toCtx);\n\t          });\n\t        }\n\t      }\n\t\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'getRouteForUrl',\n\t    value: function getRouteForUrl(url) {\n\t      var pathname = url.split('#')[0].split('?')[0];\n\t\n\t      var matchingRouteWithFewestDynamicSegments = void 0;\n\t      var fewestMatchingSegments = Infinity;\n\t\n\t      for (var rn in this.config.routes) {\n\t        var r = this.config.routes[rn];\n\t        if (r.matches(pathname)) {\n\t          if (r._keys.length === 0) {\n\t            return r;\n\t          } else if (fewestMatchingSegments === Infinity || r._keys.length < fewestMatchingSegments && r._keys[0].pattern !== '.*') {\n\t            fewestMatchingSegments = r._keys.length;\n\t            matchingRouteWithFewestDynamicSegments = r;\n\t          }\n\t        }\n\t      }\n\t      return matchingRouteWithFewestDynamicSegments;\n\t    }\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy() {\n\t      if (this.$child) {\n\t        this.$child.destroy();\n\t        delete this.$child;\n\t      }\n\t\n\t      this.query.dispose();\n\t      this.state.dispose();\n\t    }\n\t  }, {\n\t    key: 'reload',\n\t    value: function reload() {\n\t      if (this.$child) {\n\t        this.$child.destroy();\n\t        delete this.$child;\n\t      }\n\t\n\t      this.query.reload();\n\t      this.state.reload();\n\t    }\n\t  }], [{\n\t    key: 'getBase',\n\t    value: function getBase(ctx) {\n\t      var base = '';\n\t      var p = ctx;\n\t      while (p) {\n\t        base = p.config.base + (!p.config.hashbang || p.$parent ? '' : '/#!') + base;\n\t        p = p.$parent;\n\t      }\n\t      return base;\n\t    }\n\t  }, {\n\t    key: 'getCanonicalPath',\n\t    value: function getCanonicalPath(base, pathname) {\n\t      var childPath = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];\n\t      var querystring = arguments[3];\n\t      var hash = arguments.length <= 4 || arguments[4] === undefined ? '' : arguments[4];\n\t\n\t      return '' + base + pathname + childPath + (querystring ? '?' + querystring : '') + (hash ? '#' + hash : '');\n\t    }\n\t  }, {\n\t    key: 'getDepth',\n\t    value: function getDepth(ctx) {\n\t      var depth = 0;\n\t      while (ctx.$parent) {\n\t        ctx = ctx.$parent;\n\t        depth++;\n\t      }\n\t      return depth;\n\t    }\n\t  }]);\n\t\n\t  return Context;\n\t}();\n\t\n\texports.default = Context;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Stringify = __webpack_require__(5);\n\tvar Parse = __webpack_require__(7);\n\t\n\tmodule.exports = {\n\t    stringify: Stringify,\n\t    parse: Parse\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Utils = __webpack_require__(6);\n\t\n\tvar arrayPrefixGenerators = {\n\t    brackets: function brackets(prefix) {\n\t        return prefix + '[]';\n\t    },\n\t    indices: function indices(prefix, key) {\n\t        return prefix + '[' + key + ']';\n\t    },\n\t    repeat: function repeat(prefix) {\n\t        return prefix;\n\t    }\n\t};\n\t\n\tvar defaults = {\n\t    delimiter: '&',\n\t    strictNullHandling: false,\n\t    skipNulls: false,\n\t    encode: true,\n\t    encoder: Utils.encode\n\t};\n\t\n\tvar stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {\n\t    var obj = object;\n\t    if (typeof filter === 'function') {\n\t        obj = filter(prefix, obj);\n\t    } else if (obj instanceof Date) {\n\t        obj = obj.toISOString();\n\t    } else if (obj === null) {\n\t        if (strictNullHandling) {\n\t            return encoder ? encoder(prefix) : prefix;\n\t        }\n\t\n\t        obj = '';\n\t    }\n\t\n\t    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {\n\t        if (encoder) {\n\t            return [encoder(prefix) + '=' + encoder(obj)];\n\t        }\n\t        return [prefix + '=' + String(obj)];\n\t    }\n\t\n\t    var values = [];\n\t\n\t    if (typeof obj === 'undefined') {\n\t        return values;\n\t    }\n\t\n\t    var objKeys;\n\t    if (Array.isArray(filter)) {\n\t        objKeys = filter;\n\t    } else {\n\t        var keys = Object.keys(obj);\n\t        objKeys = sort ? keys.sort(sort) : keys;\n\t    }\n\t\n\t    for (var i = 0; i < objKeys.length; ++i) {\n\t        var key = objKeys[i];\n\t\n\t        if (skipNulls && obj[key] === null) {\n\t            continue;\n\t        }\n\t\n\t        if (Array.isArray(obj)) {\n\t            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n\t        } else {\n\t            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n\t        }\n\t    }\n\t\n\t    return values;\n\t};\n\t\n\tmodule.exports = function (object, opts) {\n\t    var obj = object;\n\t    var options = opts || {};\n\t    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n\t    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\t    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n\t    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n\t    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;\n\t    var sort = typeof options.sort === 'function' ? options.sort : null;\n\t    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n\t    var objKeys;\n\t    var filter;\n\t\n\t    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n\t        throw new TypeError('Encoder has to be a function.');\n\t    }\n\t\n\t    if (typeof options.filter === 'function') {\n\t        filter = options.filter;\n\t        obj = filter('', obj);\n\t    } else if (Array.isArray(options.filter)) {\n\t        objKeys = filter = options.filter;\n\t    }\n\t\n\t    var keys = [];\n\t\n\t    if (typeof obj !== 'object' || obj === null) {\n\t        return '';\n\t    }\n\t\n\t    var arrayFormat;\n\t    if (options.arrayFormat in arrayPrefixGenerators) {\n\t        arrayFormat = options.arrayFormat;\n\t    } else if ('indices' in options) {\n\t        arrayFormat = options.indices ? 'indices' : 'repeat';\n\t    } else {\n\t        arrayFormat = 'indices';\n\t    }\n\t\n\t    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\t\n\t    if (!objKeys) {\n\t        objKeys = Object.keys(obj);\n\t    }\n\t\n\t    if (sort) {\n\t        objKeys.sort(sort);\n\t    }\n\t\n\t    for (var i = 0; i < objKeys.length; ++i) {\n\t        var key = objKeys[i];\n\t\n\t        if (skipNulls && obj[key] === null) {\n\t            continue;\n\t        }\n\t\n\t        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n\t    }\n\t\n\t    return keys.join(delimiter);\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar hexTable = (function () {\n\t    var array = new Array(256);\n\t    for (var i = 0; i < 256; ++i) {\n\t        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n\t    }\n\t\n\t    return array;\n\t}());\n\t\n\texports.arrayToObject = function (source, options) {\n\t    var obj = options.plainObjects ? Object.create(null) : {};\n\t    for (var i = 0; i < source.length; ++i) {\n\t        if (typeof source[i] !== 'undefined') {\n\t            obj[i] = source[i];\n\t        }\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\texports.merge = function (target, source, options) {\n\t    if (!source) {\n\t        return target;\n\t    }\n\t\n\t    if (typeof source !== 'object') {\n\t        if (Array.isArray(target)) {\n\t            target.push(source);\n\t        } else if (typeof target === 'object') {\n\t            target[source] = true;\n\t        } else {\n\t            return [target, source];\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    if (typeof target !== 'object') {\n\t        return [target].concat(source);\n\t    }\n\t\n\t    var mergeTarget = target;\n\t    if (Array.isArray(target) && !Array.isArray(source)) {\n\t        mergeTarget = exports.arrayToObject(target, options);\n\t    }\n\t\n\t    return Object.keys(source).reduce(function (acc, key) {\n\t        var value = source[key];\n\t\n\t        if (Object.prototype.hasOwnProperty.call(acc, key)) {\n\t            acc[key] = exports.merge(acc[key], value, options);\n\t        } else {\n\t            acc[key] = value;\n\t        }\n\t        return acc;\n\t    }, mergeTarget);\n\t};\n\t\n\texports.decode = function (str) {\n\t    try {\n\t        return decodeURIComponent(str.replace(/\\+/g, ' '));\n\t    } catch (e) {\n\t        return str;\n\t    }\n\t};\n\t\n\texports.encode = function (str) {\n\t    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n\t    // It has been adapted here for stricter adherence to RFC 3986\n\t    if (str.length === 0) {\n\t        return str;\n\t    }\n\t\n\t    var string = typeof str === 'string' ? str : String(str);\n\t\n\t    var out = '';\n\t    for (var i = 0; i < string.length; ++i) {\n\t        var c = string.charCodeAt(i);\n\t\n\t        if (\n\t            c === 0x2D || // -\n\t            c === 0x2E || // .\n\t            c === 0x5F || // _\n\t            c === 0x7E || // ~\n\t            (c >= 0x30 && c <= 0x39) || // 0-9\n\t            (c >= 0x41 && c <= 0x5A) || // a-z\n\t            (c >= 0x61 && c <= 0x7A) // A-Z\n\t        ) {\n\t            out += string.charAt(i);\n\t            continue;\n\t        }\n\t\n\t        if (c < 0x80) {\n\t            out = out + hexTable[c];\n\t            continue;\n\t        }\n\t\n\t        if (c < 0x800) {\n\t            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n\t            continue;\n\t        }\n\t\n\t        if (c < 0xD800 || c >= 0xE000) {\n\t            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n\t            continue;\n\t        }\n\t\n\t        i += 1;\n\t        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n\t        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];\n\t    }\n\t\n\t    return out;\n\t};\n\t\n\texports.compact = function (obj, references) {\n\t    if (typeof obj !== 'object' || obj === null) {\n\t        return obj;\n\t    }\n\t\n\t    var refs = references || [];\n\t    var lookup = refs.indexOf(obj);\n\t    if (lookup !== -1) {\n\t        return refs[lookup];\n\t    }\n\t\n\t    refs.push(obj);\n\t\n\t    if (Array.isArray(obj)) {\n\t        var compacted = [];\n\t\n\t        for (var i = 0; i < obj.length; ++i) {\n\t            if (obj[i] && typeof obj[i] === 'object') {\n\t                compacted.push(exports.compact(obj[i], refs));\n\t            } else if (typeof obj[i] !== 'undefined') {\n\t                compacted.push(obj[i]);\n\t            }\n\t        }\n\t\n\t        return compacted;\n\t    }\n\t\n\t    var keys = Object.keys(obj);\n\t    for (var j = 0; j < keys.length; ++j) {\n\t        var key = keys[j];\n\t        obj[key] = exports.compact(obj[key], refs);\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\texports.isRegExp = function (obj) {\n\t    return Object.prototype.toString.call(obj) === '[object RegExp]';\n\t};\n\t\n\texports.isBuffer = function (obj) {\n\t    if (obj === null || typeof obj === 'undefined') {\n\t        return false;\n\t    }\n\t\n\t    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n\t};\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Utils = __webpack_require__(6);\n\t\n\tvar defaults = {\n\t    delimiter: '&',\n\t    depth: 5,\n\t    arrayLimit: 20,\n\t    parameterLimit: 1000,\n\t    strictNullHandling: false,\n\t    plainObjects: false,\n\t    allowPrototypes: false,\n\t    allowDots: false,\n\t    decoder: Utils.decode\n\t};\n\t\n\tvar parseValues = function parseValues(str, options) {\n\t    var obj = {};\n\t    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\t\n\t    for (var i = 0; i < parts.length; ++i) {\n\t        var part = parts[i];\n\t        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\t\n\t        if (pos === -1) {\n\t            obj[options.decoder(part)] = '';\n\t\n\t            if (options.strictNullHandling) {\n\t                obj[options.decoder(part)] = null;\n\t            }\n\t        } else {\n\t            var key = options.decoder(part.slice(0, pos));\n\t            var val = options.decoder(part.slice(pos + 1));\n\t\n\t            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t                obj[key] = [].concat(obj[key]).concat(val);\n\t            } else {\n\t                obj[key] = val;\n\t            }\n\t        }\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\tvar parseObject = function parseObject(chain, val, options) {\n\t    if (!chain.length) {\n\t        return val;\n\t    }\n\t\n\t    var root = chain.shift();\n\t\n\t    var obj;\n\t    if (root === '[]') {\n\t        obj = [];\n\t        obj = obj.concat(parseObject(chain, val, options));\n\t    } else {\n\t        obj = options.plainObjects ? Object.create(null) : {};\n\t        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n\t        var index = parseInt(cleanRoot, 10);\n\t        if (\n\t            !isNaN(index) &&\n\t            root !== cleanRoot &&\n\t            String(index) === cleanRoot &&\n\t            index >= 0 &&\n\t            (options.parseArrays && index <= options.arrayLimit)\n\t        ) {\n\t            obj = [];\n\t            obj[index] = parseObject(chain, val, options);\n\t        } else {\n\t            obj[cleanRoot] = parseObject(chain, val, options);\n\t        }\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\tvar parseKeys = function parseKeys(givenKey, val, options) {\n\t    if (!givenKey) {\n\t        return;\n\t    }\n\t\n\t    // Transform dot notation to bracket notation\n\t    var key = options.allowDots ? givenKey.replace(/\\.([^\\.\\[]+)/g, '[$1]') : givenKey;\n\t\n\t    // The regex chunks\n\t\n\t    var parent = /^([^\\[\\]]*)/;\n\t    var child = /(\\[[^\\[\\]]*\\])/g;\n\t\n\t    // Get the parent\n\t\n\t    var segment = parent.exec(key);\n\t\n\t    // Stash the parent if it exists\n\t\n\t    var keys = [];\n\t    if (segment[1]) {\n\t        // If we aren't using plain objects, optionally prefix keys\n\t        // that would overwrite object prototype properties\n\t        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {\n\t            if (!options.allowPrototypes) {\n\t                return;\n\t            }\n\t        }\n\t\n\t        keys.push(segment[1]);\n\t    }\n\t\n\t    // Loop through children appending to the array until we hit depth\n\t\n\t    var i = 0;\n\t    while ((segment = child.exec(key)) !== null && i < options.depth) {\n\t        i += 1;\n\t        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n\t            if (!options.allowPrototypes) {\n\t                continue;\n\t            }\n\t        }\n\t        keys.push(segment[1]);\n\t    }\n\t\n\t    // If there's a remainder, just add whatever is left\n\t\n\t    if (segment) {\n\t        keys.push('[' + key.slice(segment.index) + ']');\n\t    }\n\t\n\t    return parseObject(keys, val, options);\n\t};\n\t\n\tmodule.exports = function (str, opts) {\n\t    var options = opts || {};\n\t\n\t    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n\t        throw new TypeError('Decoder has to be a function.');\n\t    }\n\t\n\t    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n\t    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n\t    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n\t    options.parseArrays = options.parseArrays !== false;\n\t    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n\t    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n\t    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n\t    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n\t    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n\t    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\t\n\t    if (str === '' || str === null || typeof str === 'undefined') {\n\t        return options.plainObjects ? Object.create(null) : {};\n\t    }\n\t\n\t    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n\t    var obj = options.plainObjects ? Object.create(null) : {};\n\t\n\t    // Iterate over the keys and setup the new object\n\t\n\t    var keys = Object.keys(tempObj);\n\t    for (var i = 0; i < keys.length; ++i) {\n\t        var key = keys[i];\n\t        var newObj = parseKeys(key, tempObj[key], options);\n\t        obj = Utils.merge(obj, newObj, options);\n\t    }\n\t\n\t    return Utils.compact(obj);\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.factory = factory;\n\t\n\tvar _knockout = __webpack_require__(1);\n\t\n\tvar _knockout2 = _interopRequireDefault(_knockout);\n\t\n\tvar _qs = __webpack_require__(4);\n\t\n\tvar _qs2 = _interopRequireDefault(_qs);\n\t\n\tvar _utils = __webpack_require__(9);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar qsParams = {};\n\tvar trigger = _knockout2.default.observable(true);\n\tvar cache = {};\n\t\n\tvar Query = function () {\n\t  function Query(ctx) {\n\t    _classCallCheck(this, Query);\n\t\n\t    this.ctx = ctx;\n\t\n\t    if (!this.ctx.$parent) {\n\t      var qsIndex = window.location.href.indexOf('?');\n\t      if (~qsIndex) {\n\t        this.updateFromString(window.location.href.split('?')[1]);\n\t      }\n\t    }\n\t\n\t    // make work w/ click bindings w/o closure\n\t    this.get = this.get.bind(this);\n\t    this.clear = this.clear.bind(this);\n\t    this.update = this.update.bind(this);\n\t  }\n\t\n\t  _createClass(Query, [{\n\t    key: 'get',\n\t    value: function get(prop, defaultVal) {\n\t      var parser = arguments.length <= 2 || arguments[2] === undefined ? _utils.identity : arguments[2];\n\t\n\t      var query = this;\n\t      var ctx = this.ctx;\n\t      var guid = this.ctx.config.depth + ctx.pathname();\n\t\n\t      if (!cache[guid]) {\n\t        cache[guid] = {};\n\t      }\n\t\n\t      if (!cache[guid][prop]) {\n\t        cache[guid][prop] = {\n\t          defaultVal: defaultVal,\n\t          parser: parser,\n\t          value: _knockout2.default.pureComputed({\n\t            read: function read() {\n\t              trigger();\n\t\n\t              if (qsParams && qsParams[guid] && !(0, _utils.isUndefined)(qsParams[guid][prop])) {\n\t                return cache[guid][prop].parser(qsParams[guid][prop]);\n\t              }\n\t\n\t              return defaultVal;\n\t            },\n\t            write: function write(v) {\n\t              if ((0, _utils.deepEquals)(v, this.prev)) {\n\t                return;\n\t              }\n\t              this.prev = v;\n\t\n\t              (0, _utils.merge)(qsParams, _defineProperty({}, guid, _defineProperty({}, prop, v)), false);\n\t\n\t              ctx.update(location.pathname + location.hash, ctx.state(), false, query.getNonDefaultParams()[guid]);\n\t              trigger(!trigger());\n\t            },\n\t\n\t            owner: {\n\t              prev: null\n\t            }\n\t          })\n\t        };\n\t      }\n\t      return cache[guid][prop].value;\n\t    }\n\t  }, {\n\t    key: 'getAll',\n\t    value: function getAll() {\n\t      var asObservable = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\t      var pathname = arguments.length <= 1 || arguments[1] === undefined ? this.ctx.pathname() : arguments[1];\n\t\n\t      var guid = this.ctx.config.depth + pathname;\n\t      return asObservable ? _knockout2.default.pureComputed({\n\t        read: function read() {\n\t          trigger();\n\t          return this.getAll();\n\t        },\n\t        write: function write(q) {\n\t          for (var pn in q) {\n\t            this.get(pn)(q[pn]);\n\t          }\n\t        }\n\t      }, this) : _knockout2.default.toJS((0, _utils.mapKeys)(qsParams[guid] || {}, function (prop) {\n\t        return cache[guid] && cache[guid][prop] ? (0, _utils.isUndefined)(qsParams[guid][prop]) ? undefined : cache[guid][prop].parser(qsParams[guid][prop]) : qsParams[guid][prop];\n\t      }));\n\t    }\n\t  }, {\n\t    key: 'setDefaults',\n\t    value: function setDefaults(q) {\n\t      var parser = arguments.length <= 1 || arguments[1] === undefined ? _utils.identity : arguments[1];\n\t\n\t      for (var pn in q) {\n\t        this.get(pn, q[pn], parser);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear(pathname) {\n\t      if (typeof pathname !== 'string') {\n\t        pathname = this.ctx.pathname();\n\t      }\n\t      var guid = this.ctx.config.depth + pathname;\n\t      for (var pn in cache[guid]) {\n\t        var p = cache[guid][pn];\n\t        p.value(p.defaultVal);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'reload',\n\t    value: function reload() {\n\t      var force = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\t      var guid = arguments.length <= 1 || arguments[1] === undefined ? this.ctx.config.depth + this.ctx.pathname() : arguments[1];\n\t\n\t      if (!this.ctx.config.persistQuery || force) {\n\t        for (var p in qsParams[guid]) {\n\t          if (cache[guid] && cache[guid][p]) {\n\t            cache[guid][p].value.dispose();\n\t          }\n\t        }\n\t        delete qsParams[guid];\n\t        delete cache[guid];\n\t      }\n\t      trigger(!trigger());\n\t    }\n\t  }, {\n\t    key: 'dispose',\n\t    value: function dispose() {\n\t      for (var guid in qsParams) {\n\t        if (guid.indexOf(this.ctx.config.depth) === 0) {\n\t          this.reload(true, guid);\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: 'update',\n\t    value: function update() {\n\t      var query = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t      var pathname = arguments.length <= 1 || arguments[1] === undefined ? this.ctx.pathname() : arguments[1];\n\t\n\t      var guid = this.ctx.config.depth + pathname;\n\t\n\t      if ((0, _utils.deepEquals)(qsParams[guid], query)) {\n\t        return;\n\t      }\n\t\n\t      (0, _utils.merge)(qsParams, _defineProperty({}, guid, query), false);\n\t      trigger(!trigger());\n\t    }\n\t  }, {\n\t    key: 'updateFromString',\n\t    value: function updateFromString(str, pathname) {\n\t      if (pathname) {\n\t        var guid = this.ctx.config.depth + pathname;\n\t        (0, _utils.merge)(qsParams, _defineProperty({}, guid, _qs2.default.parse(str)[guid]), false);\n\t      } else {\n\t        (0, _utils.merge)(qsParams, _qs2.default.parse(str), false);\n\t      }\n\t      trigger(!trigger());\n\t    }\n\t  }, {\n\t    key: 'getNonDefaultParams',\n\t    value: function getNonDefaultParams(query, pathname) {\n\t      var nonDefaultParams = {};\n\t      var workingParams = qsParams;\n\t\n\t      if (query) {\n\t        (0, _utils.merge)(workingParams, _defineProperty({}, this.ctx.config.depth + pathname, query), false);\n\t      }\n\t\n\t      for (var id in workingParams) {\n\t        if (!cache[id]) {\n\t          nonDefaultParams[id] = workingParams[id];\n\t        } else {\n\t          nonDefaultParams[id] = {};\n\t          for (var pn in workingParams[id]) {\n\t            var p = workingParams[id][pn];\n\t            var d = cache[id][pn].defaultVal;\n\t            if (!(0, _utils.isUndefined)(p) && !(0, _utils.deepEquals)(p, d)) {\n\t              nonDefaultParams[id][pn] = p;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return nonDefaultParams;\n\t    }\n\t  }, {\n\t    key: 'getFullQueryString',\n\t    value: function getFullQueryString(query, pathname) {\n\t      return _qs2.default.stringify(this.getNonDefaultParams(query, pathname));\n\t    }\n\t  }]);\n\t\n\t  return Query;\n\t}();\n\t\n\tfunction factory(ctx) {\n\t  return new Query(ctx);\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\texports.decodeURLEncodedURIComponent = decodeURLEncodedURIComponent;\n\texports.deepEquals = deepEquals;\n\texports.extend = extend;\n\texports.identity = identity;\n\texports.isUndefined = isUndefined;\n\texports.mapKeys = mapKeys;\n\texports.merge = merge;\n\t\n\tvar _knockout = __webpack_require__(1);\n\t\n\tvar _knockout2 = _interopRequireDefault(_knockout);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction decodeURLEncodedURIComponent(val) {\n\t  if (typeof val !== 'string') {\n\t    return val;\n\t  }\n\t  return decodeURIComponent(val.replace(/\\+/g, ' '));\n\t}\n\t\n\tfunction deepEquals(foo, bar) {\n\t  if (foo === null || bar === null) {\n\t    return foo === null && bar === null;\n\t  }\n\t  if ((typeof foo === 'undefined' ? 'undefined' : _typeof(foo)) !== (typeof bar === 'undefined' ? 'undefined' : _typeof(bar))) {\n\t    return false;\n\t  }\n\t  if (isUndefined(foo)) {\n\t    return isUndefined(bar);\n\t  }\n\t  if (isPrimitiveOrDate(foo) && isPrimitiveOrDate(bar)) {\n\t    return foo === bar;\n\t  }\n\t\n\t  if (foo.constructor === Object && bar.constructor === Object) {\n\t    var fooProps = Object.keys(foo);\n\t    var barProps = Object.keys(bar);\n\t    if (fooProps.length !== barProps.length) {\n\t      return false;\n\t    }\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\t\n\t    try {\n\t      for (var _iterator = fooProps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t        var prop = _step.value;\n\t\n\t        if (!deepEquals(foo[prop], bar[prop])) {\n\t          return false;\n\t        }\n\t      }\n\t    } catch (err) {\n\t      _didIteratorError = true;\n\t      _iteratorError = err;\n\t    } finally {\n\t      try {\n\t        if (!_iteratorNormalCompletion && _iterator.return) {\n\t          _iterator.return();\n\t        }\n\t      } finally {\n\t        if (_didIteratorError) {\n\t          throw _iteratorError;\n\t        }\n\t      }\n\t    }\n\t\n\t    return true;\n\t  } else if (Array.isArray(foo) && Array.isArray(bar)) {\n\t    if (foo.length !== bar.length) {\n\t      return false;\n\t    }\n\t    var _iteratorNormalCompletion2 = true;\n\t    var _didIteratorError2 = false;\n\t    var _iteratorError2 = undefined;\n\t\n\t    try {\n\t      for (var _iterator2 = foo[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t        var el = _step2.value;\n\t\n\t        if (bar.indexOf(el) < 0) {\n\t          return false;\n\t        }\n\t      }\n\t    } catch (err) {\n\t      _didIteratorError2 = true;\n\t      _iteratorError2 = err;\n\t    } finally {\n\t      try {\n\t        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t          _iterator2.return();\n\t        }\n\t      } finally {\n\t        if (_didIteratorError2) {\n\t          throw _iteratorError2;\n\t        }\n\t      }\n\t    }\n\t  } else {\n\t    return foo === bar;\n\t  }\n\t}\n\t\n\tfunction extend(dest, src) {\n\t  var createAsObservable = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];\n\t\n\t  var _shallow = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\t\n\t  var props = Object.keys(src);\n\t\n\t  var _iteratorNormalCompletion3 = true;\n\t  var _didIteratorError3 = false;\n\t  var _iteratorError3 = undefined;\n\t\n\t  try {\n\t    for (var _iterator3 = props[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t      var prop = _step3.value;\n\t\n\t      if (isUndefined(dest[prop])) {\n\t        dest[prop] = createAsObservable ? fromJS(src[prop]) : src[prop];\n\t      } else if (_knockout2.default.isWritableObservable(dest[prop])) {\n\t        if (!deepEquals(dest[prop](), src[prop])) {\n\t          dest[prop](src[prop]);\n\t        }\n\t      } else if (isUndefined(src[prop])) {\n\t        dest[prop] = undefined;\n\t      } else if (src[prop].constructor === Object) {\n\t        if (_shallow) {\n\t          dest[prop] = {};\n\t        }\n\t        extend(dest[prop], src[prop], createAsObservable);\n\t      } else {\n\t        dest[prop] = src[prop];\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError3 = true;\n\t    _iteratorError3 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t        _iterator3.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError3) {\n\t        throw _iteratorError3;\n\t      }\n\t    }\n\t  }\n\t\n\t  return dest;\n\t}\n\t\n\tfunction identity(x) {\n\t  return x;\n\t}\n\t\n\tfunction isUndefined(x) {\n\t  return typeof x === 'undefined';\n\t}\n\t\n\tfunction mapKeys(obj, fn) {\n\t  var mappedObj = {};\n\t  Object.keys(obj).forEach(function (k) {\n\t    return mappedObj[k] = fn(k);\n\t  });\n\t  return mappedObj;\n\t}\n\t\n\tfunction merge(dest, src) {\n\t  var createAsObservable = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];\n\t\n\t  extend(dest, src, createAsObservable, false);\n\t}\n\t\n\tfunction fromJS(obj, parentIsArray) {\n\t  var obs = void 0;\n\t\n\t  if (isPrimitiveOrDate(obj)) obs = parentIsArray ? obj : _knockout2.default.observable(obj);else if (obj instanceof Array) {\n\t    obs = [];\n\t\n\t    for (var i = 0; i < obj.length; i++) {\n\t      obs[i] = fromJS(obj[i], true);\n\t    }obs = _knockout2.default.observableArray(obs);\n\t  } else if (obj.constructor === Object) {\n\t    obs = {};\n\t\n\t    for (var p in obj) {\n\t      obs[p] = fromJS(obj[p]);\n\t    }\n\t  }\n\t\n\t  return obs;\n\t}\n\t\n\tfunction isPrimitiveOrDate(obj) {\n\t  return obj === null || obj === undefined || obj.constructor === String || obj.constructor === Number || obj.constructor === Boolean || obj instanceof Date;\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.factory = factory;\n\t\n\tvar _knockout = __webpack_require__(1);\n\t\n\tvar _knockout2 = _interopRequireDefault(_knockout);\n\t\n\tvar _utils = __webpack_require__(9);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction factory(ctx) {\n\t  var trigger = _knockout2.default.observable(false);\n\t\n\t  var state = _knockout2.default.pureComputed({\n\t    read: function read() {\n\t      trigger();\n\t      return history.state ? history.state[ctx.config.depth + ctx.pathname()] : {};\n\t    },\n\t    write: function write(v) {\n\t      if (v) {\n\t        var s = history.state || {};\n\t        var key = ctx.config.depth + ctx.pathname();\n\t\n\t        if (!(0, _utils.deepEquals)(v, history.state ? history.state[ctx.config.depth + ctx.pathname()] : {})) {\n\t          if (s[key]) {\n\t            delete s[key];\n\t          }\n\t          s[key] = v;\n\t          history.replaceState(s, document.title);\n\t          trigger(!trigger());\n\t        }\n\t      }\n\t    }\n\t  });\n\t\n\t  var _dispose = state.dispose;\n\t\n\t  state.reload = function () {\n\t    var force = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\t    var guid = arguments.length <= 1 || arguments[1] === undefined ? ctx.config.depth + ctx.pathname() : arguments[1];\n\t\n\t    if (!ctx.config.persistState || force) {\n\t      if (history.state && history.state[guid]) {\n\t        var newState = history.state;\n\t        delete newState[guid];\n\t      }\n\t    }\n\t  };\n\t\n\t  state.dispose = function () {\n\t    for (var guid in history.state) {\n\t      if (guid.indexOf(ctx.config.depth) === 0) {\n\t        state.reload(true, guid);\n\t      }\n\t    }\n\t    _dispose.apply(state, arguments);\n\t  };\n\t\n\t  return state;\n\t}\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _pathToRegexp = __webpack_require__(12);\n\t\n\tvar _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);\n\t\n\tvar _utils = __webpack_require__(9);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Route = function () {\n\t  function Route(path, component) {\n\t    _classCallCheck(this, Route);\n\t\n\t    if (path[path.length - 1] === '!') {\n\t      path = path.replace('!', ':child_path(.*)?');\n\t    } else {\n\t      path = path.replace(/\\(?\\*\\)?/, '(.*)');\n\t    }\n\t\n\t    this.component = component;\n\t\n\t    this._keys = [];\n\t    this._regexp = (0, _pathToRegexp2.default)(path, this._keys);\n\t  }\n\t\n\t  _createClass(Route, [{\n\t    key: 'matches',\n\t    value: function matches(path) {\n\t      var qsIndex = path.indexOf('?');\n\t\n\t      if (~qsIndex) {\n\t        path = path.split('?')[0];\n\t      }\n\t\n\t      return this._regexp.exec(decodeURIComponent(path));\n\t    }\n\t  }, {\n\t    key: 'parse',\n\t    value: function parse(path) {\n\t      var childPath = void 0;\n\t      var hash = '';\n\t      var params = {};\n\t      var hIndex = path.indexOf('#');\n\t\n\t      if (~hIndex) {\n\t        var parts = path.split('#');\n\t        path = parts[0];\n\t        hash = (0, _utils.decodeURLEncodedURIComponent)(parts[1]);\n\t      }\n\t\n\t      var qsIndex = path.indexOf('?');\n\t\n\t      var _ref = ~qsIndex ? path.split('?') : [path];\n\t\n\t      var _ref2 = _slicedToArray(_ref, 2);\n\t\n\t      var pathname = _ref2[0];\n\t      var querystring = _ref2[1]; // eslint-disable-line\n\t\n\t      var matches = this._regexp.exec(decodeURIComponent(pathname));\n\t\n\t      for (var i = 1, len = matches.length; i < len; ++i) {\n\t        var k = this._keys[i - 1];\n\t        var v = (0, _utils.decodeURLEncodedURIComponent)(matches[i]);\n\t        if (v !== undefined || !hasOwnProperty.call(params, k.name)) {\n\t          if (k.name === 'child_path') {\n\t            if (v !== undefined) {\n\t              childPath = '/' + v;\n\t              path = path.substring(0, path.lastIndexOf(childPath));\n\t              pathname = pathname.substring(0, pathname.lastIndexOf(childPath));\n\t            }\n\t          } else {\n\t            params[k.name] = v;\n\t          }\n\t        }\n\t      }\n\t\n\t      return [path, params, hash, pathname, querystring, childPath];\n\t    }\n\t  }]);\n\t\n\t  return Route;\n\t}();\n\t\n\texports.default = Route;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isarray = __webpack_require__(13)\n\t\n\t/**\n\t * Expose `pathToRegexp`.\n\t */\n\tmodule.exports = pathToRegexp\n\tmodule.exports.parse = parse\n\tmodule.exports.compile = compile\n\tmodule.exports.tokensToFunction = tokensToFunction\n\tmodule.exports.tokensToRegExp = tokensToRegExp\n\t\n\t/**\n\t * The main path matching regexp utility.\n\t *\n\t * @type {RegExp}\n\t */\n\tvar PATH_REGEXP = new RegExp([\n\t  // Match escaped characters that would otherwise appear in future matches.\n\t  // This allows the user to escape special characters that won't transform.\n\t  '(\\\\\\\\.)',\n\t  // Match Express-style parameters and un-named parameters with a prefix\n\t  // and optional suffixes. Matches appear as:\n\t  //\n\t  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n\t  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n\t  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n\t  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n\t].join('|'), 'g')\n\t\n\t/**\n\t * Parse a string for the raw tokens.\n\t *\n\t * @param  {string} str\n\t * @return {!Array}\n\t */\n\tfunction parse (str) {\n\t  var tokens = []\n\t  var key = 0\n\t  var index = 0\n\t  var path = ''\n\t  var res\n\t\n\t  while ((res = PATH_REGEXP.exec(str)) != null) {\n\t    var m = res[0]\n\t    var escaped = res[1]\n\t    var offset = res.index\n\t    path += str.slice(index, offset)\n\t    index = offset + m.length\n\t\n\t    // Ignore already escaped sequences.\n\t    if (escaped) {\n\t      path += escaped[1]\n\t      continue\n\t    }\n\t\n\t    var next = str[index]\n\t    var prefix = res[2]\n\t    var name = res[3]\n\t    var capture = res[4]\n\t    var group = res[5]\n\t    var modifier = res[6]\n\t    var asterisk = res[7]\n\t\n\t    // Push the current path onto the tokens.\n\t    if (path) {\n\t      tokens.push(path)\n\t      path = ''\n\t    }\n\t\n\t    var partial = prefix != null && next != null && next !== prefix\n\t    var repeat = modifier === '+' || modifier === '*'\n\t    var optional = modifier === '?' || modifier === '*'\n\t    var delimiter = res[2] || '/'\n\t    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\t\n\t    tokens.push({\n\t      name: name || key++,\n\t      prefix: prefix || '',\n\t      delimiter: delimiter,\n\t      optional: optional,\n\t      repeat: repeat,\n\t      partial: partial,\n\t      asterisk: !!asterisk,\n\t      pattern: escapeGroup(pattern)\n\t    })\n\t  }\n\t\n\t  // Match any characters still remaining.\n\t  if (index < str.length) {\n\t    path += str.substr(index)\n\t  }\n\t\n\t  // If the path exists, push it onto the end.\n\t  if (path) {\n\t    tokens.push(path)\n\t  }\n\t\n\t  return tokens\n\t}\n\t\n\t/**\n\t * Compile a string to a template function for the path.\n\t *\n\t * @param  {string}             str\n\t * @return {!function(Object=, Object=)}\n\t */\n\tfunction compile (str) {\n\t  return tokensToFunction(parse(str))\n\t}\n\t\n\t/**\n\t * Prettier encoding of URI path segments.\n\t *\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tfunction encodeURIComponentPretty (str) {\n\t  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n\t *\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tfunction encodeAsterisk (str) {\n\t  return encodeURI(str).replace(/[?#]/g, function (c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Expose a method for transforming tokens into the path function.\n\t */\n\tfunction tokensToFunction (tokens) {\n\t  // Compile all the tokens into regexps.\n\t  var matches = new Array(tokens.length)\n\t\n\t  // Compile all the patterns before compilation.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    if (typeof tokens[i] === 'object') {\n\t      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n\t    }\n\t  }\n\t\n\t  return function (obj, opts) {\n\t    var path = ''\n\t    var data = obj || {}\n\t    var options = opts || {}\n\t    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\t\n\t    for (var i = 0; i < tokens.length; i++) {\n\t      var token = tokens[i]\n\t\n\t      if (typeof token === 'string') {\n\t        path += token\n\t\n\t        continue\n\t      }\n\t\n\t      var value = data[token.name]\n\t      var segment\n\t\n\t      if (value == null) {\n\t        if (token.optional) {\n\t          // Prepend partial segment prefixes.\n\t          if (token.partial) {\n\t            path += token.prefix\n\t          }\n\t\n\t          continue\n\t        } else {\n\t          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n\t        }\n\t      }\n\t\n\t      if (isarray(value)) {\n\t        if (!token.repeat) {\n\t          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n\t        }\n\t\n\t        if (value.length === 0) {\n\t          if (token.optional) {\n\t            continue\n\t          } else {\n\t            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n\t          }\n\t        }\n\t\n\t        for (var j = 0; j < value.length; j++) {\n\t          segment = encode(value[j])\n\t\n\t          if (!matches[i].test(segment)) {\n\t            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n\t          }\n\t\n\t          path += (j === 0 ? token.prefix : token.delimiter) + segment\n\t        }\n\t\n\t        continue\n\t      }\n\t\n\t      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\t\n\t      if (!matches[i].test(segment)) {\n\t        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n\t      }\n\t\n\t      path += token.prefix + segment\n\t    }\n\t\n\t    return path\n\t  }\n\t}\n\t\n\t/**\n\t * Escape a regular expression string.\n\t *\n\t * @param  {string} str\n\t * @return {string}\n\t */\n\tfunction escapeString (str) {\n\t  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n\t}\n\t\n\t/**\n\t * Escape the capturing group by escaping special characters and meaning.\n\t *\n\t * @param  {string} group\n\t * @return {string}\n\t */\n\tfunction escapeGroup (group) {\n\t  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n\t}\n\t\n\t/**\n\t * Attach the keys as a property of the regexp.\n\t *\n\t * @param  {!RegExp} re\n\t * @param  {Array}   keys\n\t * @return {!RegExp}\n\t */\n\tfunction attachKeys (re, keys) {\n\t  re.keys = keys\n\t  return re\n\t}\n\t\n\t/**\n\t * Get the flags for a regexp from the options.\n\t *\n\t * @param  {Object} options\n\t * @return {string}\n\t */\n\tfunction flags (options) {\n\t  return options.sensitive ? '' : 'i'\n\t}\n\t\n\t/**\n\t * Pull out keys from a regexp.\n\t *\n\t * @param  {!RegExp} path\n\t * @param  {!Array}  keys\n\t * @return {!RegExp}\n\t */\n\tfunction regexpToRegexp (path, keys) {\n\t  // Use a negative lookahead to match only capturing groups.\n\t  var groups = path.source.match(/\\((?!\\?)/g)\n\t\n\t  if (groups) {\n\t    for (var i = 0; i < groups.length; i++) {\n\t      keys.push({\n\t        name: i,\n\t        prefix: null,\n\t        delimiter: null,\n\t        optional: false,\n\t        repeat: false,\n\t        partial: false,\n\t        asterisk: false,\n\t        pattern: null\n\t      })\n\t    }\n\t  }\n\t\n\t  return attachKeys(path, keys)\n\t}\n\t\n\t/**\n\t * Transform an array into a regexp.\n\t *\n\t * @param  {!Array}  path\n\t * @param  {Array}   keys\n\t * @param  {!Object} options\n\t * @return {!RegExp}\n\t */\n\tfunction arrayToRegexp (path, keys, options) {\n\t  var parts = []\n\t\n\t  for (var i = 0; i < path.length; i++) {\n\t    parts.push(pathToRegexp(path[i], keys, options).source)\n\t  }\n\t\n\t  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\t\n\t  return attachKeys(regexp, keys)\n\t}\n\t\n\t/**\n\t * Create a path regexp from string input.\n\t *\n\t * @param  {string}  path\n\t * @param  {!Array}  keys\n\t * @param  {!Object} options\n\t * @return {!RegExp}\n\t */\n\tfunction stringToRegexp (path, keys, options) {\n\t  var tokens = parse(path)\n\t  var re = tokensToRegExp(tokens, options)\n\t\n\t  // Attach keys back to the regexp.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    if (typeof tokens[i] !== 'string') {\n\t      keys.push(tokens[i])\n\t    }\n\t  }\n\t\n\t  return attachKeys(re, keys)\n\t}\n\t\n\t/**\n\t * Expose a function for taking tokens and returning a RegExp.\n\t *\n\t * @param  {!Array}  tokens\n\t * @param  {Object=} options\n\t * @return {!RegExp}\n\t */\n\tfunction tokensToRegExp (tokens, options) {\n\t  options = options || {}\n\t\n\t  var strict = options.strict\n\t  var end = options.end !== false\n\t  var route = ''\n\t  var lastToken = tokens[tokens.length - 1]\n\t  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\t\n\t  // Iterate over the tokens and create our regexp string.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    var token = tokens[i]\n\t\n\t    if (typeof token === 'string') {\n\t      route += escapeString(token)\n\t    } else {\n\t      var prefix = escapeString(token.prefix)\n\t      var capture = '(?:' + token.pattern + ')'\n\t\n\t      if (token.repeat) {\n\t        capture += '(?:' + prefix + capture + ')*'\n\t      }\n\t\n\t      if (token.optional) {\n\t        if (!token.partial) {\n\t          capture = '(?:' + prefix + '(' + capture + '))?'\n\t        } else {\n\t          capture = prefix + '(' + capture + ')?'\n\t        }\n\t      } else {\n\t        capture = prefix + '(' + capture + ')'\n\t      }\n\t\n\t      route += capture\n\t    }\n\t  }\n\t\n\t  // In non-strict mode we allow a slash at the end of match. If the path to\n\t  // match already ends with a slash, we remove it for consistency. The slash\n\t  // is valid at the end of a path match, not in the middle. This is important\n\t  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\t  if (!strict) {\n\t    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n\t  }\n\t\n\t  if (end) {\n\t    route += '$'\n\t  } else {\n\t    // In non-ending mode, we need the capturing groups to match as much as\n\t    // possible by using a positive lookahead to the end or next path segment.\n\t    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n\t  }\n\t\n\t  return new RegExp('^' + route, flags(options))\n\t}\n\t\n\t/**\n\t * Normalize the given path string, returning a regular expression.\n\t *\n\t * An empty array can be passed in for the keys, which will hold the\n\t * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n\t * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n\t *\n\t * @param  {(string|RegExp|Array)} path\n\t * @param  {(Array|Object)=}       keys\n\t * @param  {Object=}               options\n\t * @return {!RegExp}\n\t */\n\tfunction pathToRegexp (path, keys, options) {\n\t  keys = keys || []\n\t\n\t  if (!isarray(keys)) {\n\t    options = /** @type {!Object} */ (keys)\n\t    keys = []\n\t  } else if (!options) {\n\t    options = {}\n\t  }\n\t\n\t  if (path instanceof RegExp) {\n\t    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n\t  }\n\t\n\t  if (isarray(path)) {\n\t    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n\t  }\n\t\n\t  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n\t}\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return Object.prototype.toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.resolveHref = resolveHref;\n\t\n\tvar _knockout = __webpack_require__(1);\n\t\n\tvar _knockout2 = _interopRequireDefault(_knockout);\n\t\n\tvar _qs = __webpack_require__(4);\n\t\n\tvar _qs2 = _interopRequireDefault(_qs);\n\t\n\tvar _utils = __webpack_require__(9);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t_knockout2.default.bindingHandlers.path = {\n\t  init: function init(e, xx, b, x, c) {\n\t    applyBinding.call(this, e, b, c);\n\t  }\n\t};\n\t_knockout2.default.bindingHandlers.state = {\n\t  init: function init(e, xx, b, x, c) {\n\t    applyBinding.call(this, e, b, c);\n\t  }\n\t};\n\t_knockout2.default.bindingHandlers.query = {\n\t  init: function init(e, xx, b, x, c) {\n\t    applyBinding.call(this, e, b, c);\n\t  }\n\t};\n\t_knockout2.default.bindingHandlers.path.utils = { resolveHref: resolveHref };\n\t\n\tfunction resolveHref(ctx, path, query) {\n\t  var _getRoute = getRoute(ctx, path);\n\t\n\t  var _getRoute2 = _slicedToArray(_getRoute, 2);\n\t\n\t  var router = _getRoute2[0];\n\t  var route = _getRoute2[1];\n\t\n\t  var querystring = query ? '?' + _qs2.default.stringify(_knockout2.default.toJS(query)) : '';\n\t\n\t  while (router.$parent) {\n\t    route = router.config.base + route;\n\t    router = router.$parent;\n\t  }\n\t\n\t  return router ? router.config.base + (!router.config.hashbang || router.$parent ? '' : '/#!') + route + querystring : '#';\n\t}\n\t\n\tfunction applyBinding(el, bindings, ctx) {\n\t  var path = bindings.has('path') ? bindings.get('path') : false;\n\t  var query = bindings.has('query') ? bindings.get('query') : false;\n\t  var state = bindings.has('state') ? bindings.get('state') : false;\n\t\n\t  var bindingsToApply = {};\n\t  el.href = '#';\n\t\n\t  bindingsToApply.click = function (data, e) {\n\t    var debounce = 1 !== which(e);\n\t    var hasOtherTarget = el.hasAttribute('target');\n\t    var hasExternalRel = el.getAttribute('rel') === 'external';\n\t    var modifierKey = e.metaKey || e.ctrlKey || e.shiftKey;\n\t\n\t    if (debounce || hasOtherTarget || hasExternalRel || modifierKey) {\n\t      return true;\n\t    }\n\t\n\t    var _getRoute3 = getRoute(ctx, path);\n\t\n\t    var _getRoute4 = _slicedToArray(_getRoute3, 2);\n\t\n\t    var router = _getRoute4[0];\n\t    var route = _getRoute4[1];\n\t\n\t    var handled = router.update(route, _knockout2.default.toJS(state), true, _knockout2.default.toJS(query));\n\t\n\t    if (handled) {\n\t      e.preventDefault();\n\t      e.stopImmediatePropagation();\n\t    } else if (!router.$parent) {\n\t      console.error('[ko-component-router] ' + path + ' did not match any routes!'); // eslint-disable-line\n\t    }\n\t\n\t    return !handled;\n\t  };\n\t\n\t  bindingsToApply.attr = {\n\t    href: _knockout2.default.pureComputed(function () {\n\t      return resolveHref(ctx, bindings.get('path'), query);\n\t    })\n\t  };\n\t\n\t  if (path) {\n\t    bindingsToApply.css = {\n\t      'active-path': _knockout2.default.pureComputed(function () {\n\t        var _getRoute5 = getRoute(ctx, path);\n\t\n\t        var _getRoute6 = _slicedToArray(_getRoute5, 2);\n\t\n\t        var router = _getRoute6[0];\n\t        var route = _getRoute6[1];\n\t\n\t        return !router.isNavigating() && router.route() !== '' && route ? router.route().matches(route) : false;\n\t      })\n\t    };\n\t  }\n\t\n\t  // allow adjacent routers to initialize\n\t  _knockout2.default.tasks.schedule(function () {\n\t    return _knockout2.default.applyBindingsToNode(el, bindingsToApply);\n\t  });\n\t}\n\t\n\tfunction getRoute(ctx, path) {\n\t  var router = getRouter(ctx);\n\t  var route = path ? _knockout2.default.unwrap(path) : router.canonicalPath();\n\t\n\t  if (route.indexOf('//') === 0) {\n\t    route = route.replace('//', '/');\n\t\n\t    while (router.$parent) {\n\t      router = router.$parent;\n\t    }\n\t  } else {\n\t    while (route && route.match(/\\/?\\.\\./i) && router.$parent) {\n\t      router = router.$parent;\n\t      route = route.replace(/\\/?\\.\\./i, '');\n\t    }\n\t  }\n\t\n\t  return [router, route];\n\t}\n\t\n\tfunction getRouter(ctx) {\n\t  while (!(0, _utils.isUndefined)(ctx)) {\n\t    if (!(0, _utils.isUndefined)(ctx.$router)) {\n\t      return ctx.$router;\n\t    }\n\t\n\t    ctx = ctx.$parentContext;\n\t  }\n\t}\n\t\n\tfunction which(e) {\n\t  e = e || window.event;\n\t  return null === e.which ? e.button : e.which;\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** ko-component-router.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 962d751755a8caea3622\n **/","import ko from 'knockout'\nimport router from './router'\nimport './binding'\n\nko.components.register('ko-component-router', {\n  synchronous: true,\n  viewModel: router,\n  template:\n    `<div data-bind='if: ctx.route().component'>\n      <div class=\"component-wrapper\" data-bind='component: {\n        name: ctx.route().component,\n        params: ctx\n      }'></div>\n    </div>`\n})\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"ko\",\"commonjs\":\"knockout\",\"commonjs2\":\"knockout\",\"amd\":\"knockout\"}\n ** module id = 1\n ** module chunks = 0\n **/","import ko from 'knockout'\nimport Context from './context'\nimport Route from './route'\nimport { isUndefined } from './utils'\n\nconst clickEvent = (!isUndefined(document)) && document.ontouchstart\n  ? 'touchstart'\n  : 'click'\n\nclass Router {\n  constructor(el, bindingCtx, {\n    routes,\n    base = '',\n    hashbang = false,\n    inTransition = noop,\n    outTransition = noop,\n    persistState = false,\n    persistQuery = false\n  }) {\n    for (const route in routes) {\n      routes[route] = new Route(route, routes[route])\n    }\n\n    this.config = {\n      el,\n      base,\n      hashbang,\n      routes,\n      inTransition,\n      outTransition,\n      persistState,\n      persistQuery\n    }\n\n    this.ctx = new Context(bindingCtx, this.config)\n\n    this.onpopstate = this.onpopstate.bind(this)\n    this.onclick = this.onclick.bind(this)\n    window.addEventListener('popstate', this.onpopstate, false)\n    document.addEventListener(clickEvent, this.onclick, false)\n\n    let dispatch = true\n    if (this.ctx.$parent) {\n      dispatch = this.ctx.$parent.path() !== this.ctx.$parent.canonicalPath()\n    }\n\n    if (dispatch) {\n      const path = (this.config.hashbang && ~location.hash.indexOf('#!'))\n        ? location.hash.substr(2) + location.search\n        : location.pathname + location.search + location.hash\n\n      this.dispatch({ path })\n    }\n  }\n\n  dispatch({ path, state, pushState = false }) {\n    if (path.toLowerCase().indexOf(this.config.base.toLowerCase()) === 0) {\n      path = path.substr(this.config.base.length) || '/'\n    }\n\n    return this.ctx.update(path, state, pushState, false)\n  }\n\n  onpopstate({ state }) {\n    this.dispatch({\n      path: location.pathname + location.search + location.hash,\n      state: (state || {})[this.ctx.config.depth + this.ctx.pathname()]\n    })\n  }\n\n  onclick(e) {\n    if (1 !== which(e) || e.metaKey || e.ctrlKey || e.shiftKey) {\n      return\n    }\n\n    // ensure link\n    let el = e.target\n    while (el && 'A' !== el.nodeName) {\n      el = el.parentNode\n    }\n    if (!el || 'A' !== el.nodeName) {\n      return\n    }\n\n    const isDownload = el.hasAttribute('download')\n    const hasOtherTarget = el.hasAttribute('target')\n    const hasExternalRel = el.getAttribute('rel') === 'external'\n    const isMailto = ~(el.getAttribute('href') || '').indexOf('mailto:')\n    const isCrossOrigin = !sameOrigin(el.href)\n    const isEmptyHash = el.getAttribute('href') === '#'\n\n    if (isDownload || hasOtherTarget || hasExternalRel || isMailto || isCrossOrigin || isEmptyHash) {\n      return\n    }\n\n    // rebuild path\n    let path = el.pathname + el.search + (el.hash || '')\n\n    // same page\n    const orig = path\n    const base = this.config.base.replace('/#!', '')\n    if (path.toLowerCase().indexOf(base.toLowerCase()) === 0) {\n      path = path.substr(base.length)\n    }\n\n    if (this.config.hashbang) {\n      path = path.replace('/#!', '')\n    }\n\n    if (this.config.base && orig === path) {\n      return\n    }\n\n    if (this.dispatch({ path, pushState: true })) {\n      e.preventDefault()\n    }\n  }\n\n  dispose() {\n    document.removeEventListener(clickEvent, this.onclick, false)\n    window.removeEventListener('popstate', this.onpopstate, false)\n    this.ctx.destroy()\n  }\n}\n\nfunction createViewModel(routerParams, componentInfo) {\n  const el = componentInfo.element\n  const bindingCtx = ko.contextFor(el)\n  return new Router(el, bindingCtx, ko.toJS(routerParams))\n}\n\nfunction which(e) {\n  e = e || window.event\n  return null === e.which ? e.button : e.which\n}\n\nfunction noop() {}\n\nfunction sameOrigin(href) {\n  let origin = location.protocol + '//' + location.hostname\n  if (location.port) origin += ':' + location.port\n  return (href && (0 === href.indexOf(origin)))\n}\n\nexport default { createViewModel }\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/router.js\n **/","import ko from 'knockout'\nimport qs from 'qs'\nimport { factory as queryFactory } from './query'\nimport { factory as stateFactory } from './state'\nimport { extend } from './utils'\n\nexport default class Context {\n  constructor(bindingCtx, config) {\n    bindingCtx.$router = this\n\n    let parentRouterBindingCtx = bindingCtx\n    let isRoot = true\n    while (parentRouterBindingCtx.$parentContext) {\n      parentRouterBindingCtx = parentRouterBindingCtx.$parentContext\n      if (parentRouterBindingCtx.$router) {\n        isRoot = false\n        break\n      } else {\n        parentRouterBindingCtx.$router = this\n      }\n    }\n\n    if (isRoot) {\n      ko.router = this\n    } else {\n      this.$parent = parentRouterBindingCtx.$router\n      this.$parent.$child = this\n      config.base = this.$parent.pathname()\n    }\n\n    this.config = config\n    this.config.depth = Context.getDepth(this)\n\n    this.isNavigating = ko.observable(true)\n\n    this.route = ko.observable('')\n    this.canonicalPath = ko.observable('')\n    this.path = ko.observable('')\n    this.pathname = ko.observable('')\n    this.hash = ko.observable('')\n    this.params = {}\n    this.query = queryFactory(this)\n    this.state = stateFactory(this)\n  }\n\n  update(origUrl = this.canonicalPath(), state = false, push = true, query = false) {\n    let url = (origUrl + '').replace('/#!', '')\n\n    if (url.indexOf('./') === 0) {\n      url = url.replace('./', '/')\n    } else {\n      let p = this\n      while (p && url.indexOf(p.config.base) > -1) {\n        url = url.replace(p.config.base, '')\n        p = p.$parent\n      }\n    }\n\n    const route = this.getRouteForUrl(url)\n    const firstRun = this.route() === ''\n\n    if (!route) {\n      return this.$parent ? this.$parent.update(...arguments) : false\n    }\n\n    const fromCtx = ko.toJS({\n      route: this.route,\n      path: this.path,\n      pathname: this.pathname,\n      canonicalPath: this.canonicalPath,\n      hash: this.hash,\n      state: this.state,\n      params: this.params,\n      query: this.query.getAll(false, this.pathname())\n    })\n\n    const [path, params, hash, pathname, querystring, childPath] = route.parse(url)\n\n    const samePage = this.pathname() === pathname\n    if (!samePage && !firstRun) {\n      this.isNavigating(true)\n      this.reload()\n    }\n\n    if (!query && querystring) {\n      query = qs.parse(querystring)[this.config.depth + pathname]\n    }\n\n    const canonicalPath = Context\n      .getCanonicalPath(\n        Context.getBase(this).replace(/\\/$/, ''),\n        pathname,\n        childPath,\n        this.query.getFullQueryString(query, pathname),\n        hash)\n\n    const toCtx = {\n      route,\n      path,\n      pathname,\n      canonicalPath,\n      hash,\n      params,\n      query\n    }\n\n    if (state === false && samePage) {\n      extend(toCtx, { state: fromCtx.state }, false)\n    } else if (!this.config.persistState && state) {\n      toCtx.state = state\n    }\n\n    if (this.config.persistState) {\n      toCtx.state = this.state()\n    }\n\n    history[push ? 'pushState' : 'replaceState'](\n      history.state,\n      document.title,\n      '' === canonicalPath ? Context.getBase(this) : canonicalPath)\n\n    if (firstRun) {\n      complete.call(this, true)\n    } else if (!samePage) {\n      this.config.outTransition(this.config.el, fromCtx, toCtx, complete.bind(this))\n\n      if (this.config.outTransition.length !== 4) {\n        complete.call(this, true)\n      }\n    } else if (this.$child) {\n      this.$child.update(childPath || '/', {}, false, {})\n      complete.call(this)\n    } else {\n      complete.call(this)\n    }\n\n    function complete(animate) {\n      const el = this.config.el.getElementsByClassName('component-wrapper')[0]\n      delete toCtx.query\n      extend(this, toCtx)\n      if (query) {\n        this.query.update(query, pathname)\n      }\n      this.isNavigating(false)\n      ko.tasks.runEarly()\n\n      if (animate) {\n        ko.tasks.schedule(() =>\n          this.config.inTransition(el, fromCtx, toCtx))\n      }\n    }\n\n    return true\n  }\n\n  getRouteForUrl(url) {\n    const pathname = url\n      .split('#')[0]\n      .split('?')[0]\n\n    let matchingRouteWithFewestDynamicSegments\n    let fewestMatchingSegments = Infinity\n\n    for (const rn in this.config.routes) {\n      const r = this.config.routes[rn]\n      if (r.matches(pathname)) {\n        if (r._keys.length === 0) {\n          return r\n        } else if (fewestMatchingSegments === Infinity ||\n          (r._keys.length < fewestMatchingSegments && r._keys[0].pattern !== '.*')) {\n          fewestMatchingSegments = r._keys.length\n          matchingRouteWithFewestDynamicSegments = r\n        }\n      }\n    }\n    return matchingRouteWithFewestDynamicSegments\n  }\n\n  destroy() {\n    if (this.$child) {\n      this.$child.destroy()\n      delete this.$child\n    }\n\n    this.query.dispose()\n    this.state.dispose()\n  }\n\n  reload() {\n    if (this.$child) {\n      this.$child.destroy()\n      delete this.$child\n    }\n\n    this.query.reload()\n    this.state.reload()\n  }\n\n  static getBase(ctx) {\n    let base = ''\n    let p = ctx\n    while (p) {\n      base = p.config.base + (!p.config.hashbang || p.$parent ? '' : '/#!') + base\n      p = p.$parent\n    }\n    return base\n  }\n\n  static getCanonicalPath(base, pathname, childPath = '', querystring, hash = '') {\n    return `${base}${pathname}${childPath}${querystring ? '?' + querystring : ''}${hash ? '#' + hash : ''}`\n  }\n\n  static getDepth(ctx) {\n    let depth = 0\n    while (ctx.$parent) {\n      ctx = ctx.$parent\n      depth++\n    }\n    return depth\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/context.js\n **/","'use strict';\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/index.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nvar Utils = require('./utils');\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar defaults = {\n    delimiter: '&',\n    strictNullHandling: false,\n    skipNulls: false,\n    encode: true,\n    encoder: Utils.encode\n};\n\nvar stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    } else if (obj === null) {\n        if (strictNullHandling) {\n            return encoder ? encoder(prefix) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {\n        if (encoder) {\n            return [encoder(prefix) + '=' + encoder(obj)];\n        }\n        return [prefix + '=' + String(obj)];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        } else {\n            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        }\n    }\n\n    return values;\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = opts || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n    var objKeys;\n    var filter;\n\n    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    } else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n    }\n\n    return keys.join(delimiter);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/stringify.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\nvar hexTable = (function () {\n    var array = new Array(256);\n    for (var i = 0; i < 256; ++i) {\n        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n    }\n\n    return array;\n}());\n\nexports.arrayToObject = function (source, options) {\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nexports.merge = function (target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        } else if (typeof target === 'object') {\n            target[source] = true;\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (Array.isArray(target) && !Array.isArray(source)) {\n        mergeTarget = exports.arrayToObject(target, options);\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (Object.prototype.hasOwnProperty.call(acc, key)) {\n            acc[key] = exports.merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nexports.decode = function (str) {\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, references) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    var refs = references || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0; i < obj.length; ++i) {\n            if (obj[i] && typeof obj[i] === 'object') {\n                compacted.push(exports.compact(obj[i], refs));\n            } else if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var j = 0; j < keys.length; ++j) {\n        var key = keys[j];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nexports.isBuffer = function (obj) {\n    if (obj === null || typeof obj === 'undefined') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/utils.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\nvar Utils = require('./utils');\n\nvar defaults = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false,\n    decoder: Utils.decode\n};\n\nvar parseValues = function parseValues(str, options) {\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[options.decoder(part)] = '';\n\n            if (options.strictNullHandling) {\n                obj[options.decoder(part)] = null;\n            }\n        } else {\n            var key = options.decoder(part.slice(0, pos));\n            var val = options.decoder(part.slice(pos + 1));\n\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                obj[key] = [].concat(obj[key]).concat(val);\n            } else {\n                obj[key] = val;\n            }\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function parseObject(chain, val, options) {\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(parseObject(chain, val, options));\n    } else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (\n            !isNaN(index) &&\n            root !== cleanRoot &&\n            String(index) === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays && index <= options.arrayLimit)\n        ) {\n            obj = [];\n            obj[index] = parseObject(chain, val, options);\n        } else {\n            obj[cleanRoot] = parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\nvar parseKeys = function parseKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^\\.\\[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n            if (!options.allowPrototypes) {\n                continue;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts || {};\n\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qs/lib/parse.js\n ** module id = 7\n ** module chunks = 0\n **/","import ko from 'knockout'\nimport qs from 'qs'\nimport { deepEquals, identity, isUndefined, mapKeys, merge } from './utils'\n\nconst qsParams = {}\nconst trigger = ko.observable(true)\nconst cache = {}\n\nclass Query {\n  constructor(ctx) {\n    this.ctx = ctx\n\n    if (!this.ctx.$parent) {\n      const qsIndex = window.location.href.indexOf('?')\n      if (~qsIndex) {\n        this.updateFromString(window.location.href.split('?')[1])\n      }\n    }\n\n    // make work w/ click bindings w/o closure\n    this.get = this.get.bind(this)\n    this.clear = this.clear.bind(this)\n    this.update = this.update.bind(this)\n  }\n\n  get(prop, defaultVal, parser = identity) {\n    const query = this\n    const ctx = this.ctx\n    const guid = this.ctx.config.depth + ctx.pathname()\n\n    if (!cache[guid]) {\n      cache[guid] = {}\n    }\n\n    if (!cache[guid][prop]) {\n      cache[guid][prop] = {\n        defaultVal,\n        parser,\n        value: ko.pureComputed({\n          read() {\n            trigger()\n\n            if (qsParams && qsParams[guid] && !isUndefined(qsParams[guid][prop])) {\n              return cache[guid][prop].parser(qsParams[guid][prop])\n            }\n\n            return defaultVal\n          },\n          write(v) {\n            if (deepEquals(v, this.prev)) {\n              return\n            }\n            this.prev = v\n\n            merge(qsParams, {\n              [guid]: { [prop]: v }\n            }, false)\n\n            ctx.update(location.pathname + location.hash, ctx.state(), false, query.getNonDefaultParams()[guid])\n            trigger(!trigger())\n          },\n          owner: {\n            prev: null\n          }\n        })\n      }\n    }\n    return cache[guid][prop].value\n  }\n\n  getAll(asObservable = false, pathname = this.ctx.pathname()) {\n    const guid = this.ctx.config.depth + pathname\n    return asObservable\n      ? ko.pureComputed({\n          read() {\n            trigger()\n            return this.getAll()\n          },\n          write(q) {\n            for (const pn in q) {\n              this.get(pn)(q[pn])\n            }\n          }\n        }, this)\n      : ko.toJS(mapKeys(qsParams[guid] || {}, (prop) =>\n          cache[guid] && cache[guid][prop]\n            ? isUndefined(qsParams[guid][prop])\n              ? undefined\n              : cache[guid][prop].parser(qsParams[guid][prop])\n            : qsParams[guid][prop]))\n  }\n\n  setDefaults(q, parser = identity) {\n    for (const pn in q) {\n      this.get(pn, q[pn], parser)\n    }\n  }\n\n  clear(pathname) {\n    if (typeof pathname !== 'string') {\n      pathname = this.ctx.pathname()\n    }\n    const guid = this.ctx.config.depth + pathname\n    for (const pn in cache[guid]) {\n      const p = cache[guid][pn]\n      p.value(p.defaultVal)\n    }\n  }\n\n  reload(force = false, guid = this.ctx.config.depth + this.ctx.pathname()) {\n    if (!this.ctx.config.persistQuery || force) {\n      for (const p in qsParams[guid]) {\n        if (cache[guid] && cache[guid][p]) {\n          cache[guid][p].value.dispose()\n        }\n      }\n      delete qsParams[guid]\n      delete cache[guid]\n    }\n    trigger(!trigger())\n  }\n\n  dispose() {\n    for (const guid in qsParams) {\n      if (guid.indexOf(this.ctx.config.depth) === 0) {\n        this.reload(true, guid)\n      }\n    }\n  }\n\n  update(query = {}, pathname = this.ctx.pathname()) {\n    const guid = this.ctx.config.depth + pathname\n\n    if (deepEquals(qsParams[guid], query)) {\n      return\n    }\n\n    merge(qsParams, { [guid]: query }, false)\n    trigger(!trigger())\n  }\n\n  updateFromString(str, pathname) {\n    if (pathname) {\n      const guid = this.ctx.config.depth + pathname\n      merge(qsParams, { [guid]: qs.parse(str)[guid] }, false)\n    } else {\n      merge(qsParams, qs.parse(str), false)\n    }\n    trigger(!trigger())\n  }\n\n  getNonDefaultParams(query, pathname) {\n    const nonDefaultParams = {}\n    const workingParams = qsParams\n\n    if (query) {\n      merge(workingParams, { [this.ctx.config.depth + pathname]: query }, false)\n    }\n\n    for (const id in workingParams) {\n      if (!cache[id]) {\n        nonDefaultParams[id] = workingParams[id]\n      } else {\n        nonDefaultParams[id] = {}\n        for (const pn in workingParams[id]) {\n          const p = workingParams[id][pn]\n          const d = cache[id][pn].defaultVal\n          if (!isUndefined(p) && !deepEquals(p, d)) {\n            nonDefaultParams[id][pn] = p\n          }\n        }\n      }\n    }\n\n    return nonDefaultParams\n  }\n\n  getFullQueryString(query, pathname) {\n    return qs.stringify(this.getNonDefaultParams(query, pathname))\n  }\n}\n\nexport function factory(ctx) {\n  return new Query(ctx)\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/query.js\n **/","import ko from 'knockout'\n\nexport function decodeURLEncodedURIComponent(val) {\n  if (typeof val !== 'string') { return val }\n  return decodeURIComponent(val.replace(/\\+/g, ' '))\n}\n\nexport function deepEquals(foo, bar) {\n  if (foo === null || bar === null) {\n    return foo === null && bar === null\n  }\n  if (typeof foo !== typeof bar) {\n    return false\n  }\n  if (isUndefined(foo)) {\n    return isUndefined(bar)\n  }\n  if (isPrimitiveOrDate(foo) && isPrimitiveOrDate(bar)) {\n    return foo === bar\n  }\n\n\n  if (foo.constructor === Object && bar.constructor === Object) {\n    const fooProps = Object.keys(foo)\n    const barProps = Object.keys(bar)\n    if (fooProps.length !== barProps.length) {\n      return false\n    }\n    for (const prop of fooProps) {\n      if (!deepEquals(foo[prop], bar[prop])) {\n        return false\n      }\n    }\n    return true\n  } else if (Array.isArray(foo) && Array.isArray(bar)) {\n    if (foo.length !== bar.length) {\n      return false\n    }\n    for (const el of foo) {\n      if (bar.indexOf(el) < 0) {\n        return false\n      }\n    }\n  } else {\n    return foo === bar\n  }\n}\n\nexport function extend(dest, src, createAsObservable = true, _shallow = true) {\n  const props = Object.keys(src)\n\n  for (const prop of props) {\n    if (isUndefined(dest[prop])) {\n      dest[prop] = createAsObservable ? fromJS(src[prop]) : src[prop]\n    } else if (ko.isWritableObservable(dest[prop])) {\n      if (!deepEquals(dest[prop](), src[prop])) {\n        dest[prop](src[prop])\n      }\n    } else if (isUndefined(src[prop])) {\n      dest[prop] = undefined\n    } else if (src[prop].constructor === Object) {\n      if (_shallow) {\n        dest[prop] = {}\n      }\n      extend(dest[prop], src[prop], createAsObservable)\n    } else {\n      dest[prop] = src[prop]\n    }\n  }\n\n  return dest\n}\n\nexport function identity(x) {\n  return x\n}\n\nexport function isUndefined(x) {\n  return typeof x === 'undefined'\n}\n\nexport function mapKeys(obj, fn) {\n  const mappedObj = {}\n  Object.keys(obj).forEach((k) => mappedObj[k] = fn(k))\n  return mappedObj\n}\n\nexport function merge(dest, src, createAsObservable = true) {\n  extend(dest, src, createAsObservable, false)\n}\n\nfunction fromJS(obj, parentIsArray) {\n  let obs\n\n  if (isPrimitiveOrDate(obj))\n    obs = parentIsArray ? obj : ko.observable(obj)\n\n  else if (obj instanceof Array) {\n    obs = []\n\n    for (let i = 0; i < obj.length; i++)\n      obs[i] = fromJS(obj[i], true)\n\n    obs = ko.observableArray(obs)\n  }\n\n  else if (obj.constructor === Object) {\n    obs = {}\n\n    for (const p in obj)\n      obs[p] = fromJS(obj[p])\n  }\n\n  return obs\n}\n\nfunction isPrimitiveOrDate(obj) {\n  return obj === null ||\n         obj === undefined ||\n         obj.constructor === String ||\n         obj.constructor === Number ||\n         obj.constructor === Boolean ||\n         obj instanceof Date\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils.js\n **/","import ko from 'knockout'\nimport { deepEquals } from './utils'\n\nexport function factory(ctx) {\n  const trigger = ko.observable(false)\n\n  const state = ko.pureComputed({\n    read() {\n      trigger()\n      return history.state ? history.state[ctx.config.depth + ctx.pathname()] : {}\n    },\n    write(v) {\n      if (v) {\n        const s = history.state || {}\n        const key = ctx.config.depth + ctx.pathname()\n\n        if (!deepEquals(v, history.state ? history.state[ctx.config.depth + ctx.pathname()] : {})) {\n          if (s[key]) {\n            delete s[key]\n          }\n          s[key] = v\n          history.replaceState(s, document.title)\n          trigger(!trigger())\n        }\n      }\n    }\n  })\n\n  const _dispose = state.dispose\n\n  state.reload = function(force = false, guid = ctx.config.depth + ctx.pathname()) {\n    if (!ctx.config.persistState || force) {\n      if (history.state && history.state[guid]) {\n        const newState = history.state\n        delete newState[guid]\n      }\n    }\n  }\n\n  state.dispose = function() {\n    for (const guid in history.state) {\n      if (guid.indexOf(ctx.config.depth) === 0) {\n        state.reload(true, guid)\n      }\n    }\n    _dispose.apply(state, arguments)\n  }\n\n  return state\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/state.js\n **/","import pathtoRegexp from 'path-to-regexp'\nimport { decodeURLEncodedURIComponent } from './utils'\n\nexport default class Route {\n  constructor(path, component) {\n    if (path[path.length - 1] === '!') {\n      path = path.replace('!', ':child_path(.*)?')\n    } else {\n      path = path.replace(/\\(?\\*\\)?/, '(.*)')\n    }\n\n    this.component = component\n\n    this._keys = []\n    this._regexp = pathtoRegexp(path, this._keys)\n  }\n\n  matches(path) {\n    const qsIndex = path.indexOf('?')\n\n    if (~qsIndex) {\n      path = path.split('?')[0]\n    }\n\n    return this._regexp.exec(decodeURIComponent(path))\n  }\n\n  parse(path) {\n    let childPath\n    let hash = ''\n    const params = {}\n    const hIndex = path.indexOf('#')\n\n    if (~hIndex) {\n      const parts = path.split('#')\n      path = parts[0]\n      hash = decodeURLEncodedURIComponent(parts[1])\n    }\n\n    const qsIndex = path.indexOf('?')\n    let [pathname, querystring] = ~qsIndex ? path.split('?') : [path] // eslint-disable-line\n    const matches = this._regexp.exec(decodeURIComponent(pathname))\n\n    for (let i = 1, len = matches.length; i < len; ++i) {\n      const k = this._keys[i - 1]\n      const v = decodeURLEncodedURIComponent(matches[i])\n      if (v !== undefined || !(hasOwnProperty.call(params, k.name))) {\n        if (k.name === 'child_path') {\n          if (v !== undefined) {\n            childPath = `/${v}`\n            path = path.substring(0, path.lastIndexOf(childPath))\n            pathname = pathname.substring(0, pathname.lastIndexOf(childPath))\n          }\n        } else {\n          params[k.name] = v\n        }\n      }\n    }\n\n    return [path, params, hash, pathname, querystring, childPath]\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/route.js\n **/","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string} str\n * @return {!Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys)\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/path-to-regexp/index.js\n ** module id = 12\n ** module chunks = 0\n **/","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/isarray/index.js\n ** module id = 13\n ** module chunks = 0\n **/","import ko from 'knockout'\nimport qs from 'qs'\nimport { isUndefined } from './utils'\n\nko.bindingHandlers.path = { init(e, xx, b, x, c) { applyBinding.call(this, e, b, c) } }\nko.bindingHandlers.state = { init(e, xx, b, x, c) { applyBinding.call(this, e, b, c) } }\nko.bindingHandlers.query = { init(e, xx, b, x, c) { applyBinding.call(this, e, b, c) } }\nko.bindingHandlers.path.utils = { resolveHref }\n\nexport function resolveHref(ctx, path, query) {\n  let [router, route] = getRoute(ctx, path)\n  const querystring = query\n    ? '?' + qs.stringify(ko.toJS(query))\n    : ''\n\n  while (router.$parent) {\n    route = router.config.base + route\n    router = router.$parent\n  }\n\n  return router\n    ? router.config.base\n      + (!router.config.hashbang || router.$parent ? '' : '/#!')\n      + route\n      + querystring\n    : '#'\n}\n\nfunction applyBinding(el, bindings, ctx) {\n  const path = bindings.has('path') ? bindings.get('path') : false\n  const query = bindings.has('query') ? bindings.get('query') : false\n  const state = bindings.has('state') ? bindings.get('state') : false\n\n  const bindingsToApply = {}\n  el.href = '#'\n\n  bindingsToApply.click = (data, e) => {\n    const debounce = 1 !== which(e)\n    const hasOtherTarget = el.hasAttribute('target')\n    const hasExternalRel = el.getAttribute('rel') === 'external'\n    const modifierKey = e.metaKey || e.ctrlKey || e.shiftKey\n\n    if (debounce || hasOtherTarget || hasExternalRel || modifierKey) {\n      return true\n    }\n\n    const [router, route] = getRoute(ctx, path)\n    const handled = router.update(route, ko.toJS(state), true, ko.toJS(query))\n\n    if (handled) {\n      e.preventDefault()\n      e.stopImmediatePropagation()\n    } else if (!router.$parent) {\n      console.error(`[ko-component-router] ${path} did not match any routes!`) // eslint-disable-line\n    }\n\n    return !handled\n  }\n\n  bindingsToApply.attr = {\n    href: ko.pureComputed(() => resolveHref(ctx, bindings.get('path'), query))\n  }\n\n  if (path) {\n    bindingsToApply.css = {\n      'active-path': ko.pureComputed(() => {\n        const [router, route] = getRoute(ctx, path)\n        return !router.isNavigating() && router.route() !== '' && route\n          ? router.route().matches(route)\n          : false\n        })\n    }\n  }\n\n  // allow adjacent routers to initialize\n  ko.tasks.schedule(() => ko.applyBindingsToNode(el, bindingsToApply))\n}\n\nfunction getRoute(ctx, path) {\n  let router = getRouter(ctx)\n  let route = path ? ko.unwrap(path) : router.canonicalPath()\n\n  if (route.indexOf('//') === 0) {\n    route = route.replace('//', '/')\n\n    while (router.$parent) {\n      router = router.$parent\n    }\n  } else {\n    while (route && route.match(/\\/?\\.\\./i) && router.$parent) {\n      router = router.$parent\n      route = route.replace(/\\/?\\.\\./i, '')\n    }\n  }\n\n  return [router, route]\n}\n\nfunction getRouter(ctx) {\n  while (!isUndefined(ctx)) {\n    if (!isUndefined(ctx.$router)) {\n      return ctx.$router\n    }\n\n    ctx = ctx.$parentContext\n  }\n}\n\nfunction which(e) {\n  e = e || window.event\n  return null === e.which ? e.button : e.which\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binding.js\n **/"],"sourceRoot":""}